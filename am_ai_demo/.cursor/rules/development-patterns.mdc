---
alwaysApply: true
---

# SAM Demo - Development Patterns Guide

Self-contained patterns for extending the SAM demo with new tables, semantic views, agents, and scenarios without requiring chat history.

## Adding New Data Tables

### Pattern 1: Dimension Tables
```sql
-- Template for new dimension tables
CREATE OR REPLACE TABLE {DATABASE_NAME}.CURATED.DIM_{ENTITY_NAME} (
    {Entity}ID BIGINT IDENTITY(1,1) PRIMARY KEY,
    {ParentEntity}ID BIGINT,                     -- FK to parent if hierarchical
    {Entity}Name VARCHAR(255) NOT NULL,
    {Entity}Code VARCHAR(100),
    {Attribute1} VARCHAR(100),
    {Attribute2} DATE,
    RecordStartDate TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP(),
    RecordEndDate TIMESTAMP_NTZ,
    IsActive BOOLEAN DEFAULT TRUE
);
```

### Pattern 2: Fact Tables
```sql
-- Template for new fact tables
CREATE OR REPLACE TABLE {DATABASE_NAME}.CURATED.FACT_{EVENT_NAME} (
    {Event}ID BIGINT IDENTITY(1,1) PRIMARY KEY,
    {Event}Date DATE NOT NULL,
    PortfolioID BIGINT,                          -- FK to DIM_PORTFOLIO
    SecurityID BIGINT,                           -- FK to DIM_SECURITY
    {MeasureColumn1} DECIMAL(38,10),
    {MeasureColumn2} DECIMAL(18,8),
    {CategoryColumn} VARCHAR(100),
    Currency CHAR(3) DEFAULT 'USD',
    SourceSystem VARCHAR(50),
    FOREIGN KEY (PortfolioID) REFERENCES DIM_PORTFOLIO(PortfolioID),
    FOREIGN KEY (SecurityID) REFERENCES DIM_SECURITY(SecurityID)
);
```

### Data Generation Function Template
```python
def build_{table_name}(session: Session, test_mode: bool = False):
    """Build {description} table using efficient SQL generation."""
    
    session.sql(f"""
        CREATE OR REPLACE TABLE {config.DATABASE_NAME}.CURATED.{TABLE_NAME} AS
        WITH base_data AS (
            SELECT 
                -- Base selection from existing tables
                {existing_table_joins}
        ),
        calculated_metrics AS (
            SELECT 
                *,
                -- Business logic calculations
                {calculated_fields}
            FROM base_data
        )
        SELECT * FROM calculated_metrics
    """).collect()
    
    print(f"✅ Created {table_name} with {specific_characteristics}")
```

## Adding New Semantic Views

### Semantic View Creation Pattern
```python
def create_{view_name}_semantic_view(session: Session):
    """Create semantic view for {specific_use_case}."""
    
    semantic_view_sql = f"""
        CREATE OR REPLACE SEMANTIC VIEW {config.DATABASE_NAME}.AI.{VIEW_NAME} (
            TABLES (
                {table_alias} AS {config.DATABASE_NAME}.CURATED.{TABLE_NAME}
                    PRIMARY KEY ({primary_key_columns})
                    WITH SYNONYMS=('{synonym1}','{synonym2}')
                    COMMENT='{table_description}'
            )
            RELATIONSHIPS (
                {relationship_name} AS {child_table}({fk_column}) REFERENCES {parent_table}({pk_column})
            )
            DIMENSIONS (
                {table_alias}.{dimension_name} AS {column_name} 
                    WITH SYNONYMS=('{dim_synonym1}','{dim_synonym2}') 
                    COMMENT='{dimension_description}'
            )
            METRICS (
                {table_alias}.{metric_name} AS {aggregation}({column_name}) 
                    WITH SYNONYMS=('{metric_synonym1}','{metric_synonym2}') 
                    COMMENT='{metric_description}'
            )
        )
    """
    
    session.sql(semantic_view_sql).collect()
    print(f"✅ Created semantic view: {VIEW_NAME}")
```

### Semantic View Validation Template
```python
def validate_{view_name}_semantic_view(session: Session):
    """Validate semantic view functionality."""
    
    # Test basic functionality
    test_result = session.sql(f"""
        SELECT * FROM SEMANTIC_VIEW(
            {config.DATABASE_NAME}.AI.{VIEW_NAME}
            METRICS {primary_metric}
            DIMENSIONS {primary_dimension}
        ) LIMIT 5
    """).collect()
    
    if len(test_result) > 0:
        print(f"✅ Semantic view {VIEW_NAME} validation passed")
    else:
        raise Exception(f"❌ Semantic view {VIEW_NAME} validation failed")
```

## Adding New Cortex Search Services

### Search Service Creation Pattern
```python
def create_{service_name}_search_service(session: Session):
    """Create Cortex Search service for {document_type}."""
    
    service_sql = f"""
        CREATE OR REPLACE CORTEX SEARCH SERVICE {config.DATABASE_NAME}.AI.SAM_{SERVICE_NAME}
            ON DOCUMENT_TEXT
            ATTRIBUTES DOCUMENT_TITLE, SecurityID, IssuerID, DOCUMENT_TYPE, PUBLISH_DATE, LANGUAGE
            WAREHOUSE = {config.CORTEX_SEARCH_WAREHOUSE}
            TARGET_LAG = '5 minutes'
            AS 
            SELECT 
                DOCUMENT_ID,
                DOCUMENT_TITLE,
                DOCUMENT_TEXT,
                SecurityID,
                IssuerID,
                DOCUMENT_TYPE,
                PUBLISH_DATE,
                LANGUAGE
            FROM {config.DATABASE_NAME}.CURATED.{CORPUS_TABLE_NAME}
    """
    
    session.sql(service_sql).collect()
    print(f"✅ Created search service: SAM_{SERVICE_NAME}")
```

### Document Corpus Creation Pattern
```python
def create_{document_type}_corpus(session: Session, documents: List[dict]):
    """Create document corpus for {document_type}."""
    
    corpus_data = []
    for doc in documents:
        corpus_data.append({
            'DOCUMENT_ID': doc['id'],
            'DOCUMENT_TITLE': doc['title'],
            'DOCUMENT_TYPE': '{DOCUMENT_TYPE}',
            'SecurityID': doc.get('security_id'),
            'IssuerID': doc.get('issuer_id'), 
            'PUBLISH_DATE': doc['date'],
            'LANGUAGE': 'en',
            'DOCUMENT_TEXT': doc['content']
        })
    
    corpus_df = session.create_dataframe(corpus_data)
    corpus_df.write.mode("overwrite").save_as_table(
        f"{config.DATABASE_NAME}.CURATED.{DOCUMENT_TYPE}_CORPUS"
    )
    
    print(f"✅ Created corpus table: {DOCUMENT_TYPE}_CORPUS")
```

## Adding New Agent Scenarios

### Agent Configuration Template
```yaml
# Agent template for new scenarios
Agent Name: {scenario_name}
Display Name: {Agent Display Name}
Description: {Business context and specific capabilities}
Orchestration Model: Claude 4

Tools:
  - {tool_1_name} (Cortex Analyst/Search)
  - {tool_2_name} (Cortex Analyst/Search)

Planning Instructions: |
  1. Analyze user query for {specific_domain} requirements
  2. Select appropriate tools based on query type:
     - {Tool 1}: Use for {specific_use_case_1}
     - {Tool 2}: Use for {specific_use_case_2}
  3. For complex queries, use multiple tools systematically
  4. Synthesize findings into coherent business insights
  5. Always provide {domain_specific} context and implications

Response Instructions: |
  1. Professional {domain} expert tone
  2. Use UK English spelling and terminology
  3. Format data clearly with tables for comparisons
  4. Include proper citations for document sources
  5. Focus on actionable {domain_specific} insights
  6. Generate charts when requested or when they enhance understanding
```

### Scenario Implementation Function
```python
def build_scenario_data(session: Session, scenario: str):
    """Build scenario-specific data and components."""
    
    scenario_configs = {
        '{scenario_name}': {
            'required_tables': ['{table1}', '{table2}'],
            'search_services': ['{service1}', '{service2}'],
            'semantic_views': ['{view1}'],
            'agent_types': ['{agent_type}']
        }
    }
    
    if scenario not in scenario_configs:
        print(f"⏭️ Scenario data for {scenario} - not implemented yet")
        return
    
    config = scenario_configs[scenario]
    
    # Build required tables
    for table in config['required_tables']:
        globals()[f'build_{table}'](session)
    
    # Create search services
    for service in config['search_services']:
        globals()[f'create_{service}_search_service'](session)
    
    # Create semantic views
    for view in config['semantic_views']:
        globals()[f'create_{view}_semantic_view'](session)
    
    print(f"✅ Built scenario data for {scenario}")
```

## Adding New Document Types

### Document Generation Pattern
```python
def generate_{document_type}_prompts(session: Session, test_mode: bool = False):
    """Generate prompts for {document_type} documents."""
    
    # Get securities/issuers for document generation
    entities = session.sql(f"""
        SELECT {required_fields}
        FROM {source_tables}
        WHERE {filtering_conditions}
        ORDER BY {prioritization_logic}
        LIMIT {document_count if test_mode else full_count}
    """).collect()
    
    prompts = []
    for entity in entities:
        prompts.append({
            'document_type': '{DOCUMENT_TYPE}',
            'entity_id': entity['{ID_FIELD}'],
            'context': {
                # Entity-specific context for LLM
            },
            'prompt': f"""
            Create a {document_type} document for {entity_context}.
            
            Requirements:
            - {specific_requirement_1}
            - {specific_requirement_2}
            - Length: {target_length}
            - Style: {target_style}
            """
        })
    
    return prompts
```

## Performance and Testing Patterns

### Data Quality Validation Template
```python
def validate_{component}_data_quality(session: Session):
    """Validate data quality for {component}."""
    
    # Test 1: Check record counts
    count_check = session.sql(f"""
        SELECT COUNT(*) as record_count 
        FROM {table_name}
    """).collect()[0]['RECORD_COUNT']
    
    assert count_check > 0, f"No records found in {table_name}"
    
    # Test 2: Check data integrity
    integrity_check = session.sql(f"""
        SELECT COUNT(*) as issues
        FROM {table_name}
        WHERE {integrity_conditions}
    """).collect()[0]['ISSUES']
    
    assert integrity_check == 0, f"Data integrity issues found: {integrity_check}"
    
    print(f"✅ Data quality validation passed for {component}")
```

### Component Testing Template  
```python
def test_{component}_functionality(session: Session):
    """Test {component} end-to-end functionality."""
    
    try:
        # Test basic functionality
        result = session.sql(f"""
            {test_query}
        """).collect()
        
        assert len(result) > 0, "No results returned"
        
        # Test specific business logic
        {specific_tests}
        
        print(f"✅ {component} functionality test passed")
        return True
        
    except Exception as e:
        print(f"❌ {component} functionality test failed: {e}")
        return False
```

## Configuration Management Patterns

### Adding New Configuration Options
```python
# In config.py - add new configuration constants
{NEW_FEATURE}_ENABLED = True
{NEW_FEATURE}_CONFIG = {
    'setting1': 'value1',
    'setting2': 'value2'
}

# Document pattern in docstring
"""
{NEW_FEATURE} Configuration:
- {NEW_FEATURE}_ENABLED: Enable/disable the feature
- {NEW_FEATURE}_CONFIG: Feature-specific settings
"""
```

### CLI Integration Pattern
```python
# In main.py - add new CLI arguments
parser.add_argument(
    '--{new-flag}',
    action='store_true',
    help='{Description of what this flag does}'
)

# Handle the flag in main logic
if args.{new_flag}:
    print(f"🔧 {Action description}...")
    result = {function_call}(session)
    if result:
        print("✅ {Success message}")
    else:
        print("❌ {Failure message}")
        return
```

This patterns guide provides complete templates for extending any aspect of the SAM demo without requiring chat history context.

**Related Documentation**:
- Agent Setup: `docs/agents_setup.md` - Complete agent configurations for all phases
- Demo Scripts: `docs/demo_scenarios.md` - Step-by-step demo conversation flows
- Troubleshooting: @troubleshooting.mdc - Issue resolution guide